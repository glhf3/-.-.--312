# -*- coding: utf-8 -*-
"""Лабораторная работа №6,Мырша Дмитрий

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RSsXllhPMsBMyE5kdtdbPDCOY6WIHDC5
"""

# 1 Из фаренгейта в кельвины 
from sklearn.linear_model import LinearRegression as LR
import matplotlib.pyplot as plt
import numpy as np
farengeit = [[-67.0],[-34.0], [0], [34.0], [54.0], [67.0], [100.0]]
kelvin = [[-55.0], [-36.6], [-17.7], [1.1], [12.2], [19.4], [37.7]]
lr = LR()
lr.fit(farengeit, kelvin)
lr.predict([[256], [123]])
lr.coef_
lr.intercept_
farengeit_test = [[-20], [-19.9], [-1.7], [2], [15.7], [20.2], [32.1]]
kelvin_test= lr.predict(farengeit_test)
kelvin_test
for f,k in zip(farengeit_test, kelvin_test):
  print('Фаренгейт', f, '   Кельвин', k)

x_range = np.arange(-20,70)
y_range = (x_range+459.67)*5/9 - 273.2
plt.figure(figsize=(15,8), dpi=280)
plt.plot(x_range, y_range, label='уравнение', linewidth='2')
plt.scatter(farengeit_test, kelvin_test, label='предсказанное значение', color='blue');
plt.xlabel('Фаренгейта')
plt.ylabel('Кельвина')
plt.legend()
plt.grid(True)
plt.show()

# 2. GitHub
!git clone https://github.com/lafirynza/--312-.-.git

# 3. График 1
import matplotlib.pyplot as plt
import numpy as np


x = np.arange(-10, 10.01, 0.01)
plt.plot(x, x**3)
plt.show()

# 3. График 2
import matplotlib.pyplot as plt
import numpy as np


x = np.arange(-10, 10.01, 0.01)
plt.plot(np.sin(x)**2)

# 3.  График 3
import matplotlib.pyplot as plt
import numpy as np
import math

x = np.arange(-10, 10, 5)

plt.plot(x)
plt.plot(x, 2+x)
plt.plot(x, x*1)
plt.plot(x, x*x*x-1)
plt.plot(x, x*1)
plt.plot(x, x*1)
plt.plot(x, x*1)
plt.plot(x, x*1)

# 4. 	Подключите библиотеку math и выведите
import math
print("Число Эйлера e =",math.e)
print("Число Пи =",math.pi)
print("nan =",math.nan)
print("Факториал числа 1! =",math.factorial(1))
print("Наибольший общий делитель =",math.gcd(1, 128))

# 5. Нарисовать кота
import matplotlib.path
import matplotlib.pyplot as plt


def drawLine(axes):

    x0 = 3
    y0 = 1

    x1 = 2
    y1 = 2

    x2 = 2
    y2 = 6

    x3 = 3
    y3 = 8

   
    x4 = 4
    y4 = 6

    x5 = 6
    y5 = 6

    x6 = 7
    y6 = 8

    x7 = 8
    y7 = 6

    x8 = 8 
    y8 = 2

    x9 = 7
    y9 = 1

    x10 = 3
    y10 = 1

    line = plt.Line2D([x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10],
                      [y0, y1, y2, y3, y4, y5 ,y6, y7, y8, y9, y10], color="r")
    axes.add_line(line)

def drawPolygons(axes):

    polygon_1 = matplotlib.patches.Polygon([(3, 1),
                                            (2, 2),
                                            (2, 6),
                                            (3, 8),
                                            (4, 6),
                                            (6, 6),
                                            (7, 8),
                                            (8, 6),
                                            (8, 2),
                                            (7, 1),
                                            (3, 1)], color="black")
 
    axes.add_patch(polygon_1)

def drawPolygon(axes):

    polygon_4 = matplotlib.patches.Polygon([(3, 4),
                                            (5, 4),
                                            (5, 5),
                                            (3, 5),
                                            ], color="black")
 
    axes.add_patch(polygon_4)

def drawCircles(axes):

    circle1 = matplotlib.patches.Circle((4, 4), radius=0.5, fill=True, color="r")
    axes.add_patch(circle1)


    circle5 = matplotlib.patches.Circle((4, 4), radius=0.2, fill=True, color="w")
    axes.add_patch(circle5)




    circle2 = matplotlib.patches.Circle((6, 4),
                                        radius=0.5,
                                        fill=True,
                                        color="r")
    axes.add_patch(circle2)

    circle3 = matplotlib.patches.Circle((6, 4),
                                        radius=0.35,
                                        fill=True,
                                        color="y")
    axes.add_patch(circle3)

    circle4 = matplotlib.patches.Circle((6, 4),
                                        radius=0.17,
                                        fill=True,
                                        color="b")
    axes.add_patch(circle4)


if __name__== "__main__":
    plt.xlim(0, 10)
    plt.ylim(0, 10)
    plt.grid()


    axes = plt.gca()
    axes.set_aspect("equal")

    drawLine(axes)
    drawPolygons(axes)
    drawCircles(axes)
    drawPolygon(axes) 
    drawArrow(axes)
    plt.show()

# 6. Fashion mnist 

# Для загрузки данных mnist
from keras.datasets import fashion_mnist
from tensorflow.keras.models import Sequential
 
# импорт различных типов скрытых слоев
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Dense, Flatten
 
# Оптимизатор Adam 
from tensorflow.keras.optimizers import Adam
import matplotlib.pyplot as plt
import numpy as np


# Разделите данные на обучение и тестирование
(trainX, trainy), (testX, testy) = fashion_mnist.load_data()
 
# Печать размеров набора данных
print('Путь: X = ', trainX.shape)
print('Тест: X = ', testX.shape)


for i in range(1, 10):
 # Создайние сетки 3x3 и размещение
 # Изображение в положении сетки
    plt.subplot(3, 3, i)
# Вставьте изображение с цветовой картой "grap"
    plt.imshow(trainX[i], cmap=plt.get_cmap('gray'))
 
# Display the entire plot
plt.show()


trainX = np.expand_dims(trainX, -1)
testX = np.expand_dims(testX, -1)
 
print(trainX.shape)

def model_arch():
    models = Sequential()
     
    # Мы учим 64 фильтры с размером ядра 5x5
    models.add(Conv2D(64, (5, 5),
                      padding="same",
                      activation="relu",
                      input_shape=(28, 28, 1)))
     
# Максимальное объединение уменьшит размер с размером ядра 2x2
    models.add(MaxPooling2D(pool_size=(2, 2)))
    models.add(Conv2D(128, (5, 5), padding="same",
                      activation="relu"))
     
    models.add(MaxPooling2D(pool_size=(2, 2)))
    models.add(Conv2D(256, (5, 5), padding="same",
                      activation="relu"))
     
    models.add(MaxPooling2D(pool_size=(2, 2)))
     
    # После выполнения операций свертки и объединения слой выравнивается и добавляются полностью связанные слои
    models.add(Flatten())
    models.add(Dense(256, activation="relu"))
     
    #Наконец поскольку всего необходимо добавить 10 классов создается слой FCC и з10 с функцией активации softmax
    models.add(Dense(10, activation="softmax"))
    return models

model = model_arch()
 
model.compile(optimizer=Adam(learning_rate=1e-3),
              loss='sparse_categorical_crossentropy',
              metrics=['sparse_categorical_accuracy'])
 
model.summary()


history = model.fit(
    trainX.astype(np.float32), trainy.astype(np.float32),
    epochs=10,
    steps_per_epoch=100,
    validation_split=0.33
)
model.save_weights('./model.h5', overwrite=True)

# Точность против графика эпохи
plt.plot(history.history['sparse_categorical_accuracy'])
plt.plot(history.history['val_sparse_categorical_accuracy'])
plt.title('Model Accuracy')
plt.ylabel('Accuracy')
plt.xlabel('epoch')
plt.legend(['train', 'val'], loc='upper left')
plt.show()

# Потеря против сюжета эпохи
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('Model Accuracy')
plt.ylabel('loss')
plt.xlabel('epoch')
plt.legend(['train', 'val'], loc='upper left')
plt.show()

# Существует 10 выходных меток для набора данных Fashion MNIST
labels = ['t_shirt', 'trouser', 'pullover', 'dress', 'coat',
          'sandal', 'shirt', 'sneaker', 'bag', 'ankle_boots']
# Сделаем прогноз
predictions = model.predict(testX[:1])
label = labels[np.argmax(predictions)]
 
print(label)
plt.imshow(testX[:1][0])
plt.show()

